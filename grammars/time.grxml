<?xml version="1.0" encoding="UTF-8"?>
<!-- This file automagically generated by convert_gsl version 2.4.0
 -->
<grammar version="1.0"
xml:lang="en-US"
mode="voice"
xmlns="http://www.w3.org/2001/06/grammar"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.w3.org/2001/06/grammar
http://www.w3.org/TR/speech-grammar/grammar.xsd"
root="Time"
tag-format="semantics/1.0">

<tag> function assignSlots(out, rules) {
        for (var nu_RULENAME in rules) {
          var nu_SLOTS = rules[nu_RULENAME].nu_SLOTS;
          for (var nu_PROPERTY in nu_SLOTS) { 
            out.nu_SLOTS[nu_PROPERTY] = nu_SLOTS[nu_PROPERTY];
          }
        }
      }
</tag>


<!--

;GSL2.0
-->

<rule id="HourNotTwelve" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var n; </tag>
<one-of>
<item>
  <ruleref uri="#OneToNine"/>
    <tag>
  n = rules.OneToNine.nu_RETURN;
  out.nu_RETURN = ((n==undefined?1:parseInt(n)) * 100);
  </tag>
</item>
<item>
  ten
<tag>out.nu_RETURN = 1000;
</tag>
</item>
<item>
  eleven
<tag>out.nu_RETURN = 1100;
</tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<rule id="Hour" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var h; </tag>
<one-of>
<item>
  <ruleref uri="#HourNotTwelve"/>
      <tag> out.nu_RETURN = rules.HourNotTwelve.nu_RETURN </tag>
</item>
<item>
  twelve
<tag>out.nu_RETURN = 0;
</tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<rule id="Minutes" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var n; var n1; var n2; </tag>
<one-of>
<item>
  ten
<tag>out.nu_RETURN = 10;
</tag>
</item>
<item>
  eleven
<tag>out.nu_RETURN = 11;
</tag>
</item>
<item>
  twelve
<tag>out.nu_RETURN = 12;
</tag>
</item>
<item>
  thirteen
<tag>out.nu_RETURN = 13;
</tag>
</item>
<item>
  fourteen
<tag>out.nu_RETURN = 14;
</tag>
</item>
<item>
  fifteen
<tag>out.nu_RETURN = 15;
</tag>
</item>
<item>
  sixteen
<tag>out.nu_RETURN = 16;
</tag>
</item>
<item>
  seventeen
<tag>out.nu_RETURN = 17;
</tag>
</item>
<item>
  eighteen
<tag>out.nu_RETURN = 18;
</tag>
</item>
<item>
  nineteen
<tag>out.nu_RETURN = 19;
</tag>
</item>
<item>
  <ruleref uri="#TwentyToFifty"/>
      <tag> out.nu_RETURN = rules.TwentyToFifty.nu_RETURN </tag>
</item>
<item>
  <ruleref uri="#TwentyToFifty"/>
    <tag>
  n1 = rules.TwentyToFifty.nu_RETURN;
  </tag>
  <ruleref uri="#OneToNine"/>
    <tag>
  n2 = rules.OneToNine.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = ((n1==undefined?0:parseInt(n1)) + (n2==undefined?0:parseInt(n2)));
  </tag>
</item>
<item>
  oh
  <ruleref uri="#OneToNine"/>
    <tag>
  n = rules.OneToNine.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = n;
  </tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<rule id="OneToNine" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
<one-of>
<item>
  one
<tag>out.nu_RETURN = 1;
</tag>
</item>
<item>
  two
<tag>out.nu_RETURN = 2;
</tag>
</item>
<item>
  three
<tag>out.nu_RETURN = 3;
</tag>
</item>
<item>
  four
<tag>out.nu_RETURN = 4;
</tag>
</item>
<item>
  five
<tag>out.nu_RETURN = 5;
</tag>
</item>
<item>
  six
<tag>out.nu_RETURN = 6;
</tag>
</item>
<item>
  seven
<tag>out.nu_RETURN = 7;
</tag>
</item>
<item>
  eight
<tag>out.nu_RETURN = 8;
</tag>
</item>
<item>
  nine
<tag>out.nu_RETURN = 9;
</tag>
</item>
</one-of>
</rule>

<rule id="TwentyToFifty" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
<one-of>
<item>
  twenty
<tag>out.nu_RETURN = 20;
</tag>
</item>
<item>
  thirty
<tag>out.nu_RETURN = 30;
</tag>
</item>
<item>
  forty
<tag>out.nu_RETURN = 40;
</tag>
</item>
<item>
  fifty
<tag>out.nu_RETURN = 50;
</tag>
</item>
</one-of>
</rule>

<rule id="AM" scope="private">
<one-of>
<item>
  in
  the
  morning
</item>
<item>
  a
  m
</item>
</one-of>
</rule>

<rule id="PM" scope="private">
<one-of>
<item>
  in
  the
<one-of>
  <item>
    afternoon
  </item>
  <item>
    evening
  </item>
</one-of>
</item>
<item>
  at
  night
</item>
<item>
  p
  m
</item>
</one-of>
</rule>

<!--

; For expressions like &quot;fifteen forty five&quot;, meaning &quot;3:45 PM&quot;
-->

<rule id="ThirteenThruTwentyFour" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
<one-of>
<item>
  thirteen
<tag>out.nu_RETURN = 1300;
</tag>
</item>
<item>
  fourteen
<tag>out.nu_RETURN = 1400;
</tag>
</item>
<item>
  fifteen
<tag>out.nu_RETURN = 1500;
</tag>
</item>
<item>
  sixteen
<tag>out.nu_RETURN = 1600;
</tag>
</item>
<item>
  seventeen
<tag>out.nu_RETURN = 1700;
</tag>
</item>
<item>
  eighteen
<tag>out.nu_RETURN = 1800;
</tag>
</item>
<item>
  nineteen
<tag>out.nu_RETURN = 1900;
</tag>
</item>
<item>
  twenty
<tag>out.nu_RETURN = 2000;
</tag>
</item>
<item>
  twenty
<one-of>
  <item>
    one
<tag>out.nu_RETURN = 2100;
</tag>
  </item>
  <item>
    two
<tag>out.nu_RETURN = 2200;
</tag>
  </item>
  <item>
    three
<tag>out.nu_RETURN = 2300;
</tag>
  </item>
  <item>
    four
<tag>out.nu_RETURN = 0;
</tag>
  </item>
</one-of>
</item>
</one-of>
</rule>

<rule id="OClock" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
o&apos;clock
<tag>out.nu_RETURN = 0;
</tag>
</rule>

<rule id="Half" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
half
<tag>out.nu_RETURN = 30;
</tag>
</rule>

<rule id="Quarter" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
quarter
<tag>out.nu_RETURN = 15;
</tag>
</rule>

<!--

; Default grammar for &quot;noon&quot;, &quot;midnight&quot;.
-->

<rule id="Twelve0" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
<one-of>
<item>
  noon
<tag>out.nu_RETURN = 1200;
</tag>
</item>
<item>
  midnight
<tag>out.nu_RETURN = 0;
</tag>
</item>
</one-of>
</rule>

<!--

; Grammar for &quot;noon&quot; and &quot;midnight&quot; used in context of &quot;before&quot; expression;
; (e.g., &quot;quarter before midnight&quot;).  Final return value will be less than
; 2400.
-->

<rule id="Twelve24" scope="private">
<tag> var nu_LATEST_RETURN;</tag>
<one-of>
<item>
  noon
<tag>out.nu_RETURN = 1200;
</tag>
</item>
<item>
  midnight
<tag>out.nu_RETURN = 2400;
</tag>
</item>
</one-of>
</rule>

<!--

; Time grammar for expressions that are AM/PM ambiguous.
; Values between 0 and 1159 are returned.
-->

<rule id="AmbigTime" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var h; var m; </tag>
<one-of>
<item>
  <ruleref uri="#Hour"/>
    <tag>
  h = rules.Hour.nu_RETURN;
  </tag>
<one-of>
  <item>
    <ruleref uri="#Minutes"/>
        <tag>
    m = rules.Minutes.nu_RETURN;
    </tag>
  </item>
  <item>
    <ruleref uri="#OClock"/>
        <tag>
    m = rules.OClock.nu_RETURN;
    </tag>
  </item>
</one-of>
  <tag>
  out.nu_RETURN = ((h==undefined?0:parseInt(h)) + (m==undefined?0:parseInt(m)));
  </tag>
</item>
<item>
  <ruleref uri="#Hour"/>
      <tag> out.nu_RETURN = rules.Hour.nu_RETURN </tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<!--

;; time grammar for hundreds time
-->

<rule id="HundredsTime" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var h; </tag>
<one-of>
<item>
  <ruleref uri="#Hour"/>
    <tag>
  h = rules.Hour.nu_RETURN;
  </tag>
  hundred
  <item repeat="0-1">
    hours
  </item>
  <tag>
  out.nu_RETURN = h;
  </tag>
</item>
<item>
  <ruleref uri="#ThirteenThruTwentyFour"/>
    <tag>
  h = rules.ThirteenThruTwentyFour.nu_RETURN;
  </tag>
  hundred
  <item repeat="0-1">
    hours
  </item>
  <tag>
  out.nu_RETURN = h;
  </tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<!--

;; before and after the hour times
-->

<rule id="RelativeAmbigTime" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var h; var m; </tag>
<one-of>
<item>
  <ruleref uri="#Quarter"/>
    <tag>
  m = rules.Quarter.nu_RETURN;
  </tag>
<one-of>
  <item>
    to
  </item>
  <item>
    til
  </item>
  <item>
    until
  </item>
  <item>
    of
  </item>
  <item>
    before
  </item>
</one-of>
  <ruleref uri="#HourNotTwelve"/>
    <tag>
  h = rules.HourNotTwelve.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = (((h==undefined?0:parseInt(h)) - 40) - (m==undefined?0:parseInt(m)));
  </tag>
</item>
<item>
  <ruleref uri="#Quarter"/>
    <tag>
  m = rules.Quarter.nu_RETURN;
  </tag>
<one-of>
  <item>
    to
  </item>
  <item>
    til
  </item>
  <item>
    until
  </item>
  <item>
    of
  </item>
  <item>
    before
  </item>
</one-of>
  twelve
  <tag>
  out.nu_RETURN = (1160 - (m==undefined?0:parseInt(m)));
  </tag>
</item>
<item>
  <ruleref uri="#Half"/>
    <tag>
  m = rules.Half.nu_RETURN;
  </tag>
  past
  <ruleref uri="#Hour"/>
    <tag>
  h = rules.Hour.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = ((h==undefined?0:parseInt(h)) + (m==undefined?0:parseInt(m)));
  </tag>
</item>
<item>
  <ruleref uri="#Quarter"/>
    <tag>
  m = rules.Quarter.nu_RETURN;
  </tag>
<one-of>
  <item>
    past
  </item>
  <item>
    after
  </item>
</one-of>
  <ruleref uri="#Hour"/>
    <tag>
  h = rules.Hour.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = ((h==undefined?0:parseInt(h)) + (m==undefined?0:parseInt(m)));
  </tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<!--

; Top-level time grammar.  The return values are integers between 0 and 2359.
; Expressions that are AM/PM ambiguous have two possible return values (e.g.,
; &quot;five o&apos;clock&quot; could return either 500 or 1700).  Expressions that are not
; AM/PM ambiguous have only a single possible return value.  This includes
; expressions that would be ambiguous except that they are followed by &quot;a m&quot;
; or &quot;p m&quot;.
-->

<rule id="TIME" scope="private">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var h; var m; var t; </tag>
<one-of>
<item>
  <ruleref uri="#AmbigTime"/>
    <tag>
  t = rules.AmbigTime.nu_RETURN;
  </tag>
  <ruleref uri="#AM"/>
  <tag>
  if (typeof(rules.AM.nu_RETURN) != 'undefined') { nu_LATEST_RETURN = rules.AM.nu_RETURN }
  </tag>
  <tag>
  out.nu_RETURN = t;
  </tag>
</item>
<item>
  <ruleref uri="#AmbigTime"/>
    <tag>
  t = rules.AmbigTime.nu_RETURN;
  </tag>
  <ruleref uri="#PM"/>
  <tag>
  if (typeof(rules.PM.nu_RETURN) != 'undefined') { nu_LATEST_RETURN = rules.PM.nu_RETURN }
  </tag>
  <tag>
  out.nu_RETURN = ((t==undefined?0:parseInt(t)) + 1200);
  </tag>
</item>
<item>
  <ruleref uri="#AmbigTime"/>
    <tag>
  t = rules.AmbigTime.nu_RETURN;
  out.nu_RETURN = ((t==undefined?0:parseInt(t)) + 1200);
  </tag>
</item>
<item>
  <ruleref uri="#AmbigTime"/>
      <tag> out.nu_RETURN = rules.AmbigTime.nu_RETURN </tag>
</item>
<item>
  <ruleref uri="#RelativeAmbigTime"/>
    <tag>
  t = rules.RelativeAmbigTime.nu_RETURN;
  out.nu_RETURN = ((t==undefined?0:parseInt(t)) + 1200);
  </tag>
</item>
<item>
  <ruleref uri="#RelativeAmbigTime"/>
      <tag> out.nu_RETURN = rules.RelativeAmbigTime.nu_RETURN </tag>
</item>
<item>
  <ruleref uri="#ThirteenThruTwentyFour"/>
    <tag>
  h = rules.ThirteenThruTwentyFour.nu_RETURN;
  </tag>
  <ruleref uri="#Minutes"/>
    <tag>
  m = rules.Minutes.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = ((h==undefined?0:parseInt(h)) + (m==undefined?0:parseInt(m)));
  </tag>
</item>
<item>
  <ruleref uri="#HundredsTime"/>
      <tag> out.nu_RETURN = rules.HundredsTime.nu_RETURN </tag>
</item>
<item>
  noon
  time
  <tag>
  out.nu_RETURN = 1200;
  </tag>
</item>
<item>
  <item repeat="0-1">
    twelve
    <item repeat="0-1">
      o&apos;clock
    </item>
  </item>
  <ruleref uri="#Twelve0"/>
    <tag>
  h = rules.Twelve0.nu_RETURN;
  </tag>
  <tag>
  out.nu_RETURN = h;
  </tag>
</item>
</one-of>
<tag> assignSlots(out, rules) </tag>
</rule>

<rule id="Time" scope="public">
<tag> out.nu_SLOTS = {}; var nu_LATEST_RETURN;</tag>
<tag> var t; </tag>
<ruleref uri="#TIME"/>
<tag> out.nu_SLOTS.time = rules.TIME.nu_RETURN; </tag>
<tag> assignSlots(out, rules) </tag>
</rule>
</grammar>

